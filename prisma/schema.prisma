// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
  output   = "../app/generated/prisma"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model Department {
  id           Int         @id @default(autoincrement())
  name         String
  manager      Employee?   @relation("DepartmentManager", fields: [managerId], references: [id])
  managerId    String?        @unique
  code         String      @unique
  employees    Employee[]  @relation("DepartmentEmployees")
  invoices     Invoice[]
  glCodings    GLCoding[]
  journalLines JournalLine[]
}

enum Role {
  admin
  manager
  staff
}


model Employee {
  id           String @id @default(uuid())
  firstName    String
  lastName     String
  email        String     @unique
  role         Role
  isActive     Boolean @default(true)
  terminatedAt DateTime?
  department   Department @relation("DepartmentEmployees", fields: [departmentId], references: [id])
  departmentId Int

  manages      Department? @relation("DepartmentManager")
  manager      Employee?  @relation("EmployeeManager", fields: [managerId], references: [id])
  managerId    String?

  subordinates Employee[] @relation("EmployeeManager")

  uploadedDocuments        Document[]           @relation("UploadedBy")
  submittedInvoices        Invoice[]            @relation("SubmittedBy")
  payments                 Payment[]
  approvals                InvoiceApprovalLog[]
  journalEntries           JournalEntry[]
  completedReconciliations BankReconciliation[] @relation("CompletedBy")

  submittedSalesInvoices SalesInvoice[] @relation("SubmittedSalesInvoices")
}


model Vendor {
  id          Int       @id @default(autoincrement())
  name        String
  contactName String
  email       String
  phone       String
  address     Address? @relation("VendorAddress")
  isActive    Boolean @default(true)
  invoices    Invoice[]
}

model Invoice {
  id            Int                  @id @default(autoincrement())
  invoiceNumber String               @unique
  invoiceDate   DateTime
  dueDate       DateTime
  totalAmount   Float
  status        String
  vendor        Vendor               @relation(fields: [vendorId], references: [id])
  vendorId      Int
  submittedBy   Employee             @relation("SubmittedBy", fields: [submittedById], references: [id])
  submittedById String
  department    Department           @relation(fields: [departmentId], references: [id])
  departmentId  Int
  glCodings     GLCoding[]
  documents     Document[]
  payments      Payment[]
  approvals     InvoiceApprovalLog[]
  currency      String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

}

model GLCoding {
  id            Int             @id @default(autoincrement())
  account       ChartOfAccount @relation(fields: [accountId], references: [id])
  accountId     Int
  description   String
  amount        Float
  invoice       Invoice?         @relation(fields: [invoiceId], references: [id])
  invoiceId     Int?
  memo         String?
  type         String? // Optional: "DR" or "CR"
  department    Department?      @relation(fields: [departmentId], references: [id])
  departmentId  Int?
  transaction   Transaction? @relation(fields: [transactionId], references: [id])
  transactionId String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt
}

model Transaction {
  id              String @id @default(uuid())
  date            DateTime @default(now())
  memo            String?
  referenceNumber String?
  type            String
  source          String?
  status          String @default("draft")
  isPosted        Boolean @default(false)
  postedAt        DateTime?

  entries GLCoding[]
}

model Document {
  id           String      @id @default(uuid())
  fileName     String
  type         String? // Enum preferred: INVOICE, RECEIPT, REPORT
  fileSize     Int?
  fileUrl      String
  uploadDate   DateTime
  invoice      Invoice? @relation(fields: [invoiceId], references: [id])
  invoiceId    Int?
  uploadedBy   Employee @relation("UploadedBy", fields: [uploadedById], references: [id])
  uploadedById String
}

model Payment {
  id          Int      @id @default(autoincrement())
  amountPaid  Float
  paymentDate DateTime
  method      String
  invoice     Invoice  @relation(fields: [invoiceId], references: [id])
  invoiceId   Int
  paidBy      Employee @relation(fields: [paidById], references: [id])
  paidById    String
}

model InvoiceApprovalLog {
  id            Int      @id @default(autoincrement())
  approvalOrder Int
  approvalDate  DateTime
  status        String
  comments      String?
  createdAt     DateTime @default(now())
  invoice       Invoice  @relation(fields: [invoiceId], references: [id])
  invoiceId     Int
  approvedBy    Employee @relation(fields: [approvedById], references: [id])
  approvedById  String
}

model ChartOfAccount {
  id            Int           @id @default(autoincrement())
  accountNumber String        @unique
  name          String
  type          String // Asset, Liability, Equity, Revenue, Expense
  isActive      Boolean       @default(true)
  glCodings     GLCoding[]
  journalLines  JournalLine[]
}

model JournalEntry {
  id          Int               @id @default(autoincrement())
  entryDate   DateTime
  memo        String?
  referenceNumber String?
  source          String?
  createdBy   Employee          @relation(fields: [createdById], references: [id])
  createdById String
  lines       JournalLine[]
  period      AccountingPeriod? @relation(fields: [periodId], references: [id])
  periodId    Int?
}

model JournalLine {
  id             Int             @id @default(autoincrement())
  journalEntry   JournalEntry    @relation(fields: [journalEntryId], references: [id])
  journalEntryId Int
  account        ChartOfAccount @relation(fields: [accountId], references: [id])
  accountId      Int
  department     Department      @relation(fields: [departmentId], references: [id])
  departmentId   Int
  amount         Float
  isDebit        Boolean
}

model Customer {
  id            String            @id @default(uuid())
  companyName   String?
  firstName     String?
  lastName      String?
  email         String         @unique
  phone         String?        @db.VarChar(20)
  address       Address?       @relation("CustomerAddress")
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  salesInvoices SalesInvoice[]
}

model Address {
  id         Int       @id @default(autoincrement())
  street     String?
  city       String?
  state      String?
  zip        String?
  country    String?
  vendor     Vendor?   @relation("VendorAddress", fields: [vendorId], references: [id])
  vendorId   Int?      @unique

  customer   Customer? @relation("CustomerAddress", fields: [customerId], references: [id])
  customerId String?   @unique  
}


model SalesInvoice {
  id            Int      @id @default(autoincrement())
  invoiceNumber String   @unique
  invoiceDate   DateTime
  dueDate       DateTime
  totalAmount   Float
  currency   String?
  taxAmount  Float?
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt
  status        String
  customer      Customer @relation(fields: [customerId], references: [id])
  customerId    String

  submittedBy   Employee @relation("SubmittedSalesInvoices", fields: [submittedById], references: [id])
  submittedById String
}

model BankAccount {
  id              Int                  @id @default(autoincrement())
  name            String
  type            String?
  isPrimary       Boolean @default(false)
  accountNumber   String
  bankName        String
  balance         Float
  transactions    BankTransaction[]
  reconciliations BankReconciliation[]
}

model BankReconciliation {
  id                 Int                 @id @default(autoincrement())
  bankAccount        BankAccount         @relation(fields: [bankAccountId], references: [id])
  bankAccountId      Int
  statementStartDate DateTime
  statementEndDate   DateTime
  openingBalance     Float
  reconciledBalance  Float
  difference         Float?
  status             ReconciliationStatus
  notes              String?
  completedBy        Employee?           @relation("CompletedBy", fields: [completedById], references: [id])
  completedById      String?
  completedAt        DateTime?
  createdAt          DateTime            @default(now())
  updatedAt          DateTime            @updatedAt

  transactions       ReconciledTransaction[]
}

enum ReconciliationStatus {
  PENDING
  RECONCILED
  FLAGGED
  IN_PROGRESS
  COMPLETED
  ERROR
}


model BankTransaction {
  id              Int                      @id @default(autoincrement())
  bankAccount     BankAccount              @relation(fields: [bankAccountId], references: [id])
  bankAccountId   Int
  amount          Float
  date            DateTime
  description     String
  reference       String?
  createdAt       DateTime                 @default(now())

  reconciliations ReconciledTransaction[]
}

model ReconciledTransaction {
  id                   Int                 @id @default(autoincrement())
  reconciliation       BankReconciliation @relation(fields: [reconciliationId], references: [id])
  reconciliationId     Int
  transaction          BankTransaction    @relation(fields: [transactionId], references: [id])
  transactionId        Int
  isMatched            Boolean            @default(false)
  matchedAt            DateTime?
  notes                String?
}



model AccountingPeriod {
  id             Int            @id @default(autoincrement())
  periodName     String // e.g., "Jul 2025"
  startDate      DateTime
  endDate        DateTime
  isClosed       Boolean        @default(false)
  createdAt      DateTime       @default(now())
  journalEntries JournalEntry[]
}
